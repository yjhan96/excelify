from __future__ import annotations

from typing import TYPE_CHECKING, Sequence

from excelify._element import Element

if TYPE_CHECKING:
    from excelify._excelframe import ExcelFrame


def int_to_alpha(idx: int) -> str:
    num_alphabets = 26

    if idx == 0:
        return "A"
    result = []
    while idx > 0:
        rem = idx % num_alphabets
        if len(result) == 0:
            result.append(chr(ord("A") + rem))
        else:
            result.append(chr(ord("A") + rem - 1))
        idx = idx // num_alphabets
    return "".join(reversed(result))


def alpha_to_int(s: str) -> int:
    """
    Converts an alphabet string (generated by the int_to_alpha function)
    back to its integer index. This function is the reverse of int_to_alpha.

    Args:
        s (str): The alphabet string to convert.

    Returns:
        int: The corresponding integer index.
    """
    num_alphabets = 26
    res = 0
    s_len = len(s)

    # Handle the special case where 'A' maps to 0 in int_to_alpha
    if s_len == 1 and s[0] == "A":
        return 0

    # Iterate through the string from right to left (least significant to most significant)
    for i, char in enumerate(reversed(s)):
        # Calculate the base value of the character ('A'=0, 'B'=1, ..., 'Z'=25)
        char_val = ord(char) - ord("A")

        if i == 0:
            # For the rightmost character (i.e., the first character processed
            # when iterating in reverse), its value is directly `char_val`
            # (equivalent to multiplying by 26^0).
            res += char_val
        else:
            # For all other characters (moving left from the rightmost),
            # the effective value is `char_val + 1`. This reverses the
            # `rem - 1` logic from `int_to_alpha`.
            # Each subsequent character's contribution is multiplied by increasing
            # powers of 26 (26^1, 26^2, etc., where the power is 'i').
            res += (char_val + 1) * (num_alphabets**i)
    return res


class CellMapping:
    def __init__(self, dfs: Sequence[tuple[ExcelFrame, tuple[int, int]]]):
        self._id_to_start_pos = {df.id: start_pos for df, start_pos in dfs}
        self._columns = {
            df.id: {c: i for i, c in enumerate(df.columns)} for df, _ in dfs
        }

    def __getitem__(self, element: Element) -> str:
        id, col_name, idx = element
        start_row, start_col = self._id_to_start_pos[id]
        col_idx = int_to_alpha(self._columns[id][col_name] + start_col)
        row_idx = idx + start_row + 1 + 1
        return f"{col_idx}{row_idx}"

    def __contains__(self, element: Element) -> bool:
        id, col_name, _ = element
        if id not in self._columns:
            return False
        if col_name not in self._columns[id]:
            return False
        return True
